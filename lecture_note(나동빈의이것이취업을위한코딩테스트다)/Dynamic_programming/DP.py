# 다이나믹 프로그래밍은 메모리를 적절히 사용해 수행 시간을 비약적으로 증가시키는 방법
# 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록합니다.
# 일반적으로 두 가지 방식 (탑다운, 바텀업) 으로 구성됩니다.

# Dynamic programming = 동적 계획법
# 자료구조에서 동적할당은 '프로그램이 실행된는 도중에 실행헤 필요한 메모리할당'
# 1. 최적 부분 구조 ( Optimal Substructure )
#    - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아 큰 문제를 해결
# 2. 중복되는 부분 문제 ( Overlapping Subproblem )
#    - 동일한 작은 문제를 반복적으로 해결

# 피보나치 수열
# 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# 점화식이란 인접한 항들 사이의 관계식을 의미
# a_n = a_n-1 + a_n-2 , a_1=1, a_2=1

def fibo(x):
    if x == 1 or x == 2:
        return 1
    return fibo(x-1) + fibo(x-2)

print(fibo(4))

# 단순히 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도를 가지게 됩니다.

# 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나입니다.
# 한 번 계산한 결과를 메모리 공간에 메모하는 기법입니다.
# 캐싱 ( Caching ) 이라고도 합니다.

# 탑다운방식, 바텀업방식
# DP의 전형적인 형태는 바텀업방식, 결과저장용 리스트는 DP 테이블이라고 부름

# 한 번 계산된 결과를 메모이제이션하기 위한 리스트 초기화
d = [0] * 100

# 피보나치 함수 (Fibonacci Function) 를 재귀함수로 구현
def dp_fibo(x):
    if x==1 or x==2:
        return 1
    if d[x] != 0:
        return d[x]

    d[x] = dp_fibo(x-1) + dp_fibo(x-2)

    return d[x]
print(dp_fibo(99))


## 다이나믹 프로그래밍 vs 분할 정복
# 다이나믹 프로그래밍과 분할정복 모두 최적 부분 구조를 가질 때 사용할 수 있음
# 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결하는상황

### 다이나믹 프로그래밍과 분할정복의 차이점은 부분문제의 중복입니다.
# DP 에서는 각 부분들이 서로 영향을 미치며 부분문제 중복
# 분할정복에서는 동일한 부분 문제가 반복적으로 계산되지 않습니다.

# 분할정복의 예인 pivot ( 퀵정렬 ) 을 보면
# 한 번 기준원소가 자리를 변경해서 자리를 잡으면 그 기준 원소의 위치는 바뀌지않음
# 분할 이후에 해당 피벗값을 다시 처리하는 부분 문제는 호출하지 않습니다.

# 먼저 그리디, 구현, 완전탐색 등의 아이디어로 문제를 해결할 수 있는지 검토한 후
# DP 를 고려

